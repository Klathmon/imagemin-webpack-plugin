{"version":3,"sources":["../src/helpers.js"],"names":["imageData","imageminOptions","imageBuffer","Buffer","isBuffer","from","originalSize","length","buffer","optimizedImageBuffer","optimizeImage","cacheFolder","filename","elseFunc","cacheFilePath","resolve","hashFilename","exists","readFile","fileBuffer","writeFile","getFromCacheIfPossible","directory","reject","access","constants","R_OK","W_OK","err","dirname","mkdirpAsync","writeFileAsync","buildTestFunction","invokeIfFunction","rawTestValue","minFileSize","maxFileSize","testFunctions","compileRegex","assetSource","func","filePath","createHash","update","digest","tests","Array","isArray","map","test","RegExp","regex","Error"],"mappings":"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","file":"helpers.js","sourcesContent":["import fs from 'fs'\nimport path from 'path'\nimport crypto from 'crypto'\nimport { makeRe } from 'minimatch'\nimport imagemin from 'imagemin'\nimport mkdirp from 'mkdirp'\nimport promisify from 'util.promisify'\n\nexport const readFile = promisify(fs.readFile)\nconst writeFileAsync = promisify(fs.writeFile)\nconst mkdirpAsync = promisify(mkdirp)\n\n/**\n * Optimizes a single image, returning the orignal if the \"optimized\" version is larger\n * @param  {Object}  imageData\n * @param  {Object}  imageminOptions\n * @return {Promise(asset)}\n */\nexport async function optimizeImage (imageData, imageminOptions) {\n  // Ensure that the contents i have are in the form of a buffer\n  const imageBuffer = (Buffer.isBuffer(imageData) ? imageData : Buffer.from(imageData, 'utf8'))\n  // And get the original size for comparison later to make sure it actually got smaller\n  const originalSize = imageBuffer.length\n\n  // Await for imagemin to do the compression\n  const optimizedImageBuffer = await imagemin.buffer(imageBuffer, imageminOptions)\n\n  // If the optimization actually produced a smaller file, then return the optimized version\n  if (optimizedImageBuffer.length < originalSize) {\n    return optimizedImageBuffer\n  } else {\n    // otherwize return the orignal\n    return imageBuffer\n  }\n}\n\n/**\n * Tests a filename to see if it matches any of the given test functions\n * This function is curried, pass in the first 3 params first, then the next 2\n * for each test needed\n * @param  {RegExp|RegExp[]|Function|Function[]|String|String[]} rawTestValue\n * @param  {Number} minFileSize\n * @param  {Number} maxFileSize\n * @return {Boolean}\n */\nexport function buildTestFunction (rawTestValue, minFileSize, maxFileSize) {\n  const testFunctions = compileRegex(rawTestValue)\n  /**\n   * @param  {String}      filename\n   * @param  {assetSource} assetSource\n   * @return {Boolean}\n   */\n  return (filename, assetSource) => {\n    for (let func of testFunctions) {\n      if (func(filename) === true) {\n        return assetSource.length > minFileSize && assetSource.length <= maxFileSize\n      }\n    }\n    return false\n  }\n}\n\n/**\n * hashes a filename to make sure I can uniquely store a file even with absolute paths\n * @param  {string} filePath The path (relative or absolute) to the file\n * @return {string}          A hash of the full file path\n */\nexport function hashFilename (filePath) {\n  return crypto.createHash('sha1').update(filePath).digest('hex')\n}\n\n/**\n * Invokes the passed in argument if it's a function\n * @param  {Function|Any}  func\n * @return {Any}\n */\nexport function invokeIfFunction (func) {\n  if (typeof func === 'function') {\n    return func()\n  } else {\n    return func\n  }\n}\n\n/**\n * Gets the buffer of the file from cache. If it doesn't exist or the cache is\n * not enabled, it will invoke elseFunc and use it's result as the result of the\n * function, saving the result in the cache\n * @param  {String} cacheFolder\n * @param  {String} filename\n * @param  {Function} elseFunc\n * @return {Buffer}\n */\nexport async function getFromCacheIfPossible (cacheFolder, filename, elseFunc) {\n  let cacheFilePath\n  if (cacheFolder !== null) {\n    cacheFilePath = path.resolve(cacheFolder, hashFilename(filename))\n    if (await exists(cacheFilePath)) {\n      return readFile(cacheFilePath)\n    }\n  }\n\n  const fileBuffer = await elseFunc()\n  if (cacheFolder !== null) {\n    await writeFile(cacheFilePath, fileBuffer)\n  }\n  return fileBuffer\n}\n\n/**\n * checks if a file/directory is accessable\n * @param {any} directory\n * @returns\n */\nexport async function exists (directory) {\n  return new Promise((resolve, reject) => {\n    fs.access(directory, fs.constants.R_OK | fs.constants.W_OK, (err) => {\n      if (err) {\n        resolve(false)\n      } else {\n        resolve(true)\n      }\n    })\n  })\n}\n\n/**\n * async wrapper for writeFile that will create the directory if it does not already exist\n * @param {String} filename\n * @param {Buffer} buffer\n * @returns\n */\nexport async function writeFile (filename, buffer) {\n  const directory = path.dirname(filename)\n  // if the directory doesn't exist, create it\n  if (!(await exists(directory))) {\n    await mkdirpAsync(directory)\n  }\n\n  return writeFileAsync(filename, buffer)\n}\n\n/**\n * Compiles a regex, glob, function, or an array of any of them to an array of functions\n * @param  {RegExp|RegExp[]|Function|Function[]|String|String[]} rawTestValue\n * @return {Function[]}\n */\nfunction compileRegex (rawTestValue) {\n  const tests = Array.isArray(rawTestValue) ? rawTestValue : [rawTestValue]\n\n  return tests.map((test) => {\n    if (typeof test === 'function') {\n      // if it's a function, just return this\n      return test\n    } else if (test instanceof RegExp) {\n      // If it's a regex return it wrapped in a function\n      return (filename) => test.test(filename)\n    } else if (typeof test === 'string') {\n      // If it's a string, let minimatch convert it to a regex then wrap that in a function\n      const regex = makeRe(test)\n      return (filename) => regex.test(filename)\n    } else {\n      throw new Error('test parameter must be a regex, glob string, function, or an array of any of them')\n    }\n  })\n}\n"]}